MEMORY MANAGEMENNT IN OS

Memory management is a function of the operating system that handles the allocation and deallocation of memory to processes during execution.

Objectives of Memory Management
Keep CPU busy by providing it with processes.
Minimize fragmentation (wasted memory).
Provide relocation, protection, sharing.
Support virtual memory.

Types of Memory
Primary memory (RAM) – fast, volatile, directly accessed by CPU.
Secondary memory (Disk) – slower, non-volatile, used as storage.

Memory Allocation Techniques

Contiguous Allocation
Each process is allocated a single continuous block of memory.
Two methods:
Fixed partitioning
ii)Dynamic partitioning

Non-Contiguous Allocation
Process can be placed in different parts of memory.
Requires mapping (like a page table).
Techniques:
Paging
Memory divided into frames and pages (fixed size).
Eliminates external fragmentation.
Example: Logical page → mapped to a physical frame.
Segmentation
Memory divided into segments (code, data, stack, etc.).
Segments are variable-sized.
Supports protection and sharing.
Suffers from external fragmentation.
iii) Paged Segmentation
Combination of paging + segmentation.

VIRTUAL MEMORY
·  Technique that allows execution of processes not entirely in memory.
·  Uses demand paging + swap space on disk.
·  Implemented using page replacement algorithms (FIFO, LRU, Optimal, etc.).
Fragmentation
Internal fragmentation → wasted space inside allocated memory.
External fragmentation → free space exists but not contiguous.
Solutions:
Paging → removes external fragmentation.
Compaction → rearrange memory to remove gaps






Paging in Operating System

Paging is a memory management scheme that eliminates the problem of contiguous memory allocation.
It allows the logical address space (program’s view of memory) to be non-contiguous while mapping it into physical memory.

Logical Address (Virtual Address)
·  Generated by the CPU.
·  Consists of:
Page Number (p): Used as an index into a page table.
Page Offset (d): Gives the exact location within the page.
Logical Address = (Page Number, Page Offset)
Physical Address
Actual address in RAM.
Consists of:
Frame Number (f): Obtained from page table.
Page Offset (d): Same as in logical address.

Physical Address = (Frame Number, Page Offset)
Page
Fixed-size block of logical memory.
Frame
Fixed-size block of physical memory.
Frame size = Page size.
Page Table
Data structure that maps page numbers → frame numbers.


PROGRAM:
#include <stdio.h>

int main() {
    int pageTable[50], n, i, logicalAddr, pageNo, offset, frameNo, physicalAddr;
    int pageSize;

    printf("Enter number of pages: ");
    scanf("%d", &n);
    printf("Enter page size (in bytes): ");
    scanf("%d", &pageSize);

    printf("Enter the page table (frame number for each page):\n");
    for(i = 0; i < n; i++) {
        printf("Page %d → Frame: ", i);
        scanf("%d", &pageTable[i]);
    }

    printf("\nEnter a logical address (page number and offset):\n");
    printf("Page Number: ");
    scanf("%d", &pageNo);
    printf("Offset: ");
    scanf("%d", &offset);

    frameNo = pageTable[pageNo];
    physicalAddr = frameNo * pageSize + offset;

    printf("\nLogical Address → (Page: %d, Offset: %d)", pageNo, offset);
    printf("\nPhysical Address → %d\n", physicalAddr);

    return 0;
}

OUTPUT
Enter number of pages: 4
Enter page size (in bytes): 100
Enter the page table (frame number for each page):
Page 0 → Frame: 2
Page 1 → Frame: 4
Page 2 → Frame: 6
Page 3 → Frame: 1

Enter a logical address (page number and offset):
Page Number: 2
Offset: 50

Logical Address → (Page: 2, Offset: 50)
Physical Address → 650


